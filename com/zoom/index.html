<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1.0, minimum-scale=1.0, width=device-width"/>
    <meta name="HandheldFriendly" content="true">
    <title>Audi VR Plans</title>
    <script>
        
    </script>

<!--
    --
    --
    --
        Styles
    --
    --
    --
-->

    <style type="text/css">/* Eric Meyer's Reset CSS v2.0 - http://cssreset.com */
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}img{width:auto;height:auto;}nav,footer,section,div,img,canvas{position:absolute;}</style>

    <style type="text/css">
        body {
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }
        #zoom_image {
            position: absolute;
            width: 4000px;
            height: auto;
            user-select: none;
            top: 50%;
            transform: translateY(-50%);
        }
        #vector_image {
            height: auto;
            user-select: none;
            top: 50%;
            transform: translateY(-50%);
        }
        #element {
            width: 600px;
            height: 600px;
        }
        .pinch-zoom-container {
            width: 600px;
            height: 600px;
        }
        .buttons {
            z-index: 1;
            position: absolute;
        }
        button {
            float: left;
            margin: 10px;
        }
        h1 {
            padding: 20px;
            font-size: 40px;
        }
        #zoom_container {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .animate {
            transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), width 0.5s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        #cover {
            position: relative;
            width: 100%;
            height: 100%;
        }
        #points {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            pointer-events: none;
        }
        #white {
            width: 100%;
            height: 100%;
            background-color: white;
            transition: opacity 2.4s cubic-bezier(0.4, 0, 0.2, 1);
            transition-delay: 0.36s;
            pointer-events: none;
        }
        .dot {
            position: absolute;
            width: 28px;
            height: 28px;
            background-color: #b51c14;
            font-size: 16px;
            text-align: center;
            border-radius: 50%;
            border-top-left-radius: 3px;
            color: white;
            font-size: 16px;
            line-height: 26px;
            user-select: none;
            pointer-events: none;
        }
        #print {
            opacity: 0;
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }
    </style>

<!--
    --
    --
    --
        Scripts
    --
    --
    --
-->

    <script>
        var lorem = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Donec molestie maximus nunc, a convallis enim hendrerit id. Aliquam in ipsum nec dui vehicula rhoncus in at ligula. Maecenas sed gravida erat. Morbi non urna ut enim sodales porttitor tincidunt eu sapien. Nunc condimentum erat non lacus semper accumsan. Praesent consequat enim sed felis eleifend porttitor. Ut eget ex ut erat pulvinar dictum. Nullam ullamcorper tempor massa, vitae suscipit est efficitur ac.';
        var elements = [
            {
                name:'Floor plan',
                src:'floor_plan.svg',
                points: [
                    {
                        id: 'human',
                        title: 'The Human Touch',
                        pos: {x:613, y:141},
                        desc: lorem,
                    },
                    {
                        id: 'robot',
                        title: 'The Robot Platform',
                        pos: {x:0, y:0},
                        desc: lorem,
                    },
                    {
                        id: 'desk',
                        title: 'Workbench',
                        pos: {x:650, y:189},
                        desc: lorem,
                    },
                ]
            },
            {
                name:'Screwdriver',
                src:'screwdriver.svg',
                points: [
                    {
                        id: 'human',
                        title: 'The Human Touch',
                        pos: {x:613, y:141},
                        desc: lorem,
                    },
                    {
                        id: 'robot',
                        title: 'The Robot Platform',
                        pos: {x:0, y:0},
                        desc: lorem,
                    },
                    {
                        id: 'desk',
                        title: 'Workbench',
                        pos: {x:650, y:189},
                        desc: lorem,
                    },
                ]
            },
            {
                name:'Robot',
                src:'big_robot.svg',
            },
        ];

        
        var pinchZoom, zoomImage, vectorImage, cover, vectorCover, slider, print, mouseBuffer;

        var W = document.documentElement.clientWidth;
        var H = document.documentElement.clientHeight;

        var imageWidth = 4000;
        var imageHeight = 0;
        var topGap = 0;

        var zoomFactor = 0.26;

        var step = 0;

        var dotRadius = 14;
        var showDots = false;

        const mouseDownCallback = (e) => {
            console.log("DOWN");
            mouseBuffer = {x:e.pageX, y:e.pageY};
        };

        window.onload = function(e) {
            document.querySelector('#white').style.opacity = 0;
            pinchZoom = document.querySelector('pinch-zoom');
            zoomImage = document.getElementById("zoom_image");
            cover = document.getElementById("cover");
            slider = document.getElementById("slider");
            print = document.getElementById("print");
            vectorCover = document.getElementById("vector_cover");
            vectorImage = document.getElementById("vector_image");
            pointContainer = document.getElementById("points");
            pointContainer.style.opacity = 0;
            pointContainer.classList.add('animate');

            zoomImage.style.display = 'none';

            console.log(elements);
            vectorImage.src = elements[step].src;
            vectorImage.style.width = imageWidth;

            function imageLoaded(e) {
                zoomImage.style.display = 'block';
                
                var bounds = zoomImage.getBoundingClientRect()
                imageHeight = imageWidth/bounds.width*bounds.height;
                
                zoomImage.style.display = 'none';
                resetDots(elements[step].points);
                onResize(null, true);
                topGap = (H/pinchZoom.scale-imageHeight)/2;
            };

            function stopAnimation(e) {
                //vectorCover.classList.add("animate");
                vectorCover.classList.remove("animate");
            };

            function zoomIn(){
                startZoom(1);
            }

            function zoomOut(){
                startZoom(-1);
            }

            function startZoom(direction, center){ // direction is 1 or -1
                var zoom = pinchZoom.scale + zoomFactor * pinchZoom.scale * direction;
                pinchZoom.scaleTo(zoom, {
                    originX: center ? center.x : W/2,
                    originY: center ? center.y : H/2,
                    relativeTo: 'container',
                    allowChangeEvent: true,
                });
            }

            /* function getPoint(point, id, count){
                return '<div class="circle" id="'+id+'" style="transform: translate('+point.x+'px, '+point.y+'px)">'+count+'</div>';
            }; */

            function updatePoints(points){
                if(points && points.length < 1) return '';
                return points.map((point, i) => getPoint(point.pos, point.id, i));
            };

            function onResize(e, reset) {
                W = document.documentElement.clientWidth;
                H = document.documentElement.clientHeight;
                pinchZoom.style.height = H+'px';
                cover.style.width = imageWidth+'px';
                cover.style.height = H/W*imageWidth+'px';
                var zoomValue = W / imageWidth;
                pinchZoom.minScale = zoomValue;
                pinchZoom.setTransform({
                    scale: zoomValue,
                    x: 0,
                    y: 0,
                    allowChangeEvent: false,
                });
                onChange(e, reset);
            };

            zoomImage.addEventListener('load', imageLoaded);
            vectorImage.addEventListener('load', imageLoaded);

            zoomImage.src = elements[0].src;

            function globalToLocal(point) {
                return {};
            };

            function localToGlobal(point) {
                return {
                    x: point
                }
            };

            function resetDots(dots){
                pointContainer.innerHTML = '';
                if(dots){
                    dots.forEach((dot, i) => {
                        const element = document.createElement('div');
                        pointContainer.appendChild(element);
                        element.id = dot.id,
                        element.classList.add('dot');
                        element.innerHTML = i+1;
                        
                    });
                }
            }
            function updateDots(dots, scale, pos, reset) {
                if(dots){
                    dots.forEach((dot, i) => {
                        const element = document.querySelector('#'+dot.id);
                        const transform =  'matrix(1, 0, 0, 1, '
                            +(pos.x + (dot.pos.x+imageWidth/2)*scale)
                            +', '
                            +(pos.y + (dot.pos.y+imageHeight/2+topGap)*scale)
                            +')';
                        element.style.transform = null;
                        element.style.transform = transform;
                    });
                    const show = pinchZoom.scale > 0.65;
                    if(showDots !== show){
                        if(show){
                            pointContainer.style.opacity = 1;
                        }else{
                            if(reset){
                                pointContainer.classList.remove('animate');
                            }

                            pointContainer.style.opacity = 0;

                            if(reset){
                                setTimeout(() => pointContainer.classList.add('animate'), 10);
                            }
                            
                        }
                        showDots = show;
                    }
                }
            };

            function onChange(e, reset){
                vectorCover.style.transform = 'translate('+pinchZoom.x+'px, '+pinchZoom.y+'px)';
                vectorCover.style.width = pinchZoom.scale * imageWidth+'px';
                vectorCover.style.height = pinchZoom.scale * H/W*imageWidth+'px';
                //console.log(elements[step].points, pinchZoom.scale, {x:pinchZoom.x, y:pinchZoom.y})
                updateDots(elements[step].points, pinchZoom.scale, {x:pinchZoom.x, y:pinchZoom.y}, reset);
            };

            function loadImage(){
                step++;
                if(step >= elements.length){
                    step = 0;
                }
                vectorImage.src = elements[step].src;
                hidePrint();
            }

            function showPrint(text) {
                print.style.opacity = 1;
                print.innerHTML = text
            };

            function hidePrint() {
                print.style.opacity = 0;
            }
            function distance(p1, p2) { 
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            }

            function traceClickPosition(e) {
                /* +(pos.x + (dot.pos.x+imageWidth/2)*scale)
                            +', '
                            +(pos.y + (dot.pos.y+imageHeight/2+topGap)*scale)
 */
                var x = Math.round((e.pageX-pinchZoom.x)/pinchZoom.scale-imageWidth/2);
                var y = Math.round((e.pageY-pinchZoom.y)/pinchZoom.scale-topGap-imageHeight/2);
                console.log('Click position: {x:'+x+', y:'+y+'}');

            }

            function onClick(e){
                console.log(Math.floor(mouseBuffer.x), e.pageX);
                var minDist = 3;
                if(distance(mouseBuffer, {x:e.pageX, y:e.pageY}) < minDist){
                    checkHit({x:e.pageX, y:e.pageY}, elements[step].points, dotRadius);
                    traceClickPosition(e);
                    console.log('click');

                }
            }

            function dotClick(i){
                console.log(elements[step].points[i].title, i);
                showPrint(elements[step].points[i].title);
            }

            function checkHit(target, points, radius){
                var clicked = false;
                if(points){
                    points.forEach((point, i) => {
                        var pos = {
                            x: (point.pos.x+imageWidth/2) * pinchZoom.scale + pinchZoom.x + dotRadius,
                            y: (point.pos.y+imageHeight/2+topGap) * pinchZoom.scale + pinchZoom.y + dotRadius,
                        }
                        //TODO: make the click target bigger only on handheld devices 
                        if(distance(target, pos) < dotRadius * 1.3 ){
                            dotClick(i);
                            clicked = true;
                        }
                        return null;
                    });
                    if(!clicked){
                        hidePrint();
                    }
                }
            }

            function onDoubleClick(e){
                if(pinchZoom.scale > pinchZoom.minScale + 0.1){
                    onResize(null, true);
                }else{
                    startZoom(12, {x:e.pageX, y:e.pageY});
                }
            }

            pinchZoom.addEventListener('change', onChange);
            pinchZoom.addEventListener('click', onClick);
            pinchZoom.addEventListener('dblclick', onDoubleClick);
            document.getElementById('plus').addEventListener('click', zoomIn);
            document.getElementById('minus').addEventListener('click', zoomOut);
            document.getElementById('load').addEventListener('click', loadImage);
            window.addEventListener('resize', onResize);
        }
    </script>
</head>


<!--
    --
    --
    --
        DOM
    --
    --
    --
-->


<body id="body">
    <div id="zoom_container">
        <div id="vector_cover">
            <img id="vector_image" src="floor_plan.svg"/>
        </div>
        <pinch-zoom>
            <div id="slider">
                <div id="cover"></div>
                <img id="zoom_image" src="floor_plan.svg"/>
            </div>
        </pinch-zoom>
    </div>
    <div id="points"></div>
    <div class="buttons">
        <button id="plus">+</button>
        <button id="minus">-</button>
        <button id="load">Load new</button>
    </div>
    </div>
    <div id="white"></div>
    <div id="print"></div>
</body>


<!--
    --
    --
    --
        Zoom Script
    --
    --
    --
-->

<script> // close this long one here
     var PinchZoom = (function () {
        'use strict';
        
        class Pointer {
            constructor(nativePointer) {
                /** Unique ID for this pointer */
                this.id = -1;
                this.nativePointer = nativePointer;
                this.pageX = nativePointer.pageX;
                this.pageY = nativePointer.pageY;
                this.clientX = nativePointer.clientX;
                this.clientY = nativePointer.clientY;
                if (self.Touch && nativePointer instanceof Touch) {
                    this.id = nativePointer.identifier;
                }
                else if (isPointerEvent(nativePointer)) { // is PointerEvent
                    this.id = nativePointer.pointerId;
                }
            }
            /**
             * Returns an expanded set of Pointers for high-resolution inputs.
             */
            getCoalesced() {
                if ('getCoalescedEvents' in this.nativePointer) {
                    return this.nativePointer.getCoalescedEvents().map(p => new Pointer(p));
                }
                return [this];
            }
        }
        const isPointerEvent = (event) => self.PointerEvent && event instanceof PointerEvent;
        const noop = () => { };
        /**
         * Track pointers across a particular element
         */
        class PointerTracker {
            /**
             * Track pointers across a particular element
             *
             * @param element Element to monitor.
             * @param callbacks
             */
            constructor(_element, callbacks) {
                this._element = _element;
                /**
                 * State of the tracked pointers when they were pressed/touched.
                 */
                this.startPointers = [];
                /**
                 * Latest state of the tracked pointers. Contains the same number
                 * of pointers, and in the same order as this.startPointers.
                 */
                this.currentPointers = [];
                const { start = () => true, move = noop, end = noop, } = callbacks;
                this._startCallback = start;
                this._moveCallback = move;
                this._endCallback = end;
                // Bind methods
                this._pointerStart = this._pointerStart.bind(this);
                this._touchStart = this._touchStart.bind(this);
                this._move = this._move.bind(this);
                this._triggerPointerEnd = this._triggerPointerEnd.bind(this);
                this._pointerEnd = this._pointerEnd.bind(this);
                this._touchEnd = this._touchEnd.bind(this);
                // Add listeners
                if (self.PointerEvent) {
                    this._element.addEventListener('pointerdown', this._pointerStart);
                }
                else {
                    this._element.addEventListener('mousedown', this._pointerStart);
                    this._element.addEventListener('touchstart', this._touchStart);
                    this._element.addEventListener('touchmove', this._move);
                    this._element.addEventListener('touchend', this._touchEnd);
                }
            }
            /**
             * Call the start callback for this pointer, and track it if the user wants.
             *
             * @param pointer Pointer
             * @param event Related event
             * @returns Whether the pointer is being tracked.
             */
            _triggerPointerStart(pointer, event) {
                if (!this._startCallback(pointer, event))
                    return false;
                this.currentPointers.push(pointer);
                this.startPointers.push(pointer);
                return true;
            }
            /**
             * Listener for mouse/pointer starts. Bound to the class in the constructor.
             *
             * @param event This will only be a MouseEvent if the browser doesn't support
             * pointer events.
             */
            _pointerStart(event) {
                if (event.button !== 0 /* Left */)
                    return;
                if (!this._triggerPointerStart(new Pointer(event), event))
                    return;
                // Add listeners for additional events.
                // The listeners may already exist, but no harm in adding them again.
                if (isPointerEvent(event)) {
                    this._element.setPointerCapture(event.pointerId);
                    this._element.addEventListener('pointermove', this._move);
                    this._element.addEventListener('pointerup', this._pointerEnd);
                }
                else { // MouseEvent
                    window.addEventListener('mousemove', this._move);
                    window.addEventListener('mouseup', this._pointerEnd);
                }
                mouseDownCallback(event);
            }
            /**
             * Listener for touchstart. Bound to the class in the constructor.
             * Only used if the browser doesn't support pointer events.
             */
            _touchStart(event) {
                for (const touch of Array.from(event.changedTouches)) {
                    this._triggerPointerStart(new Pointer(touch), event);
                }
            }
            /**
             * Listener for pointer/mouse/touch move events.
             * Bound to the class in the constructor.
             */
            _move(event) {
                const previousPointers = this.currentPointers.slice();
                const changedPointers = ('changedTouches' in event) ? // Shortcut for 'is touch event'.
                    Array.from(event.changedTouches).map(t => new Pointer(t)) :
                    [new Pointer(event)];
                const trackedChangedPointers = [];
                for (const pointer of changedPointers) {
                    const index = this.currentPointers.findIndex(p => p.id === pointer.id);
                    if (index === -1)
                        continue; // Not a pointer we're tracking
                    trackedChangedPointers.push(pointer);
                    this.currentPointers[index] = pointer;
                }
                if (trackedChangedPointers.length === 0)
                    return;
                this._moveCallback(previousPointers, trackedChangedPointers, event);
            }
            /**
             * Call the end callback for this pointer.
             *
             * @param pointer Pointer
             * @param event Related event
             */
            _triggerPointerEnd(pointer, event) {
                const index = this.currentPointers.findIndex(p => p.id === pointer.id);
                // Not a pointer we're interested in?
                if (index === -1)
                    return false;
                this.currentPointers.splice(index, 1);
                this.startPointers.splice(index, 1);
                this._endCallback(pointer, event);
                return true;
            }
            /**
             * Listener for mouse/pointer ends. Bound to the class in the constructor.
             * @param event This will only be a MouseEvent if the browser doesn't support
             * pointer events.
             */
            _pointerEnd(event) {
                if (!this._triggerPointerEnd(new Pointer(event), event))
                    return;
                if (isPointerEvent(event)) {
                    if (this.currentPointers.length)
                        return;
                    this._element.removeEventListener('pointermove', this._move);
                    this._element.removeEventListener('pointerup', this._pointerEnd);
                }
                else { // MouseEvent
                    window.removeEventListener('mousemove', this._move);
                    window.removeEventListener('mouseup', this._pointerEnd);
                }
            }
            /**
             * Listener for touchend. Bound to the class in the constructor.
             * Only used if the browser doesn't support pointer events.
             */
            _touchEnd(event) {
                for (const touch of Array.from(event.changedTouches)) {
                    this._triggerPointerEnd(new Pointer(touch), event);
                }
            }
        }

        function styleInject(css, ref) {
          if ( ref === void 0 ) ref = {};
          var insertAt = ref.insertAt;

          if (!css || typeof document === 'undefined') { return; }

          var head = document.head || document.getElementsByTagName('head')[0];
          var style = document.createElement('style');
          style.type = 'text/css';

          if (insertAt === 'top') {
            if (head.firstChild) {
              head.insertBefore(style, head.firstChild);
            } else {
              head.appendChild(style);
            }
          } else {
            head.appendChild(style);
          }

          if (style.styleSheet) {
            style.styleSheet.cssText = css;
          } else {
            style.appendChild(document.createTextNode(css));
          }
        }

        var css = "pinch-zoom {\n  display: block;\n  overflow: hidden;\n  touch-action: none;\n  --scale: 1;\n  --x: 0;\n  --y: 0;\n}\n\npinch-zoom > * {\n  transform: translate(var(--x), var(--y)) scale(var(--scale));\n  transform-origin: 0 0;\n  will-change: transform;\n}\n";
        styleInject(css);

        const minScaleAttr = 'min-scale';
        function getDistance(a, b) {
            if (!b)
                return 0;
            return Math.sqrt((b.clientX - a.clientX) ** 2 + (b.clientY - a.clientY) ** 2);
        }
        function getMidpoint(a, b) {
            if (!b)
                return a;
            return {
                clientX: (a.clientX + b.clientX) / 2,
                clientY: (a.clientY + b.clientY) / 2,
            };
        }
        function getAbsoluteValue(value, max) {
            if (typeof value === 'number')
                return value;
            if (value.trimRight().endsWith('%')) {
                return max * parseFloat(value) / 100;
            }
            return parseFloat(value);
        }
        // I'd rather use DOMMatrix/DOMPoint here, but the browser support isn't good enough.
        // Given that, better to use something everything supports.
        let cachedSvg;
        function getSVG() {
            return cachedSvg || (cachedSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'));
        }
        function createMatrix() {
            return getSVG().createSVGMatrix();
        }
        function createPoint() {
            return getSVG().createSVGPoint();
        }
        const MIN_SCALE = 0.01;
        class PinchZoom extends HTMLElement {
            constructor() {
                super();
                // Current transform.
                this._transform = createMatrix();
                // Watch for children changes.
                // Note this won't fire for initial contents,
                // so _stageElChange is also called in connectedCallback.
                new MutationObserver(() => this._stageElChange())
                    .observe(this, { childList: true });
                // Watch for pointers
                const pointerTracker = new PointerTracker(this, {
                    start: (pointer, event) => {
                        // We only want to track 2 pointers at most
                        if (pointerTracker.currentPointers.length === 2 || !this._positioningEl)
                            return false;
                        event.preventDefault();
                        return true;
                    },
                    move: (previousPointers) => {
                        this._onPointerMove(previousPointers, pointerTracker.currentPointers);
                    },
                });
                this.addEventListener('wheel', event => this._onWheel(event));
                console.log('constructor');
            }
            static get observedAttributes() { return [minScaleAttr]; }
            attributeChangedCallback(name, oldValue, newValue) {
                if (name === minScaleAttr) {
                    if (this.scale < this.minScale) {
                        this.setTransform({ scale: this.minScale });
                    }
                }
            }
            get minScale() {
                const attrValue = this.getAttribute(minScaleAttr);
                if (!attrValue)
                    return MIN_SCALE;
                const value = parseFloat(attrValue);
                if (Number.isFinite(value))
                    return Math.max(MIN_SCALE, value);
                return MIN_SCALE;
            }
            set minScale(value) {
                this.setAttribute(minScaleAttr, String(value));
            }
            connectedCallback() {
                this._stageElChange();
            }
            get x() {
                return this._transform.e;
            }
            get y() {
                return this._transform.f;
            }
            get scale() {
                return this._transform.a;
            }
            /**
             * Change the scale, adjusting x/y by a given transform origin.
             */
            scaleTo(scale, opts = {}) {
                let { originX = 0, originY = 0, } = opts;
                const { relativeTo = 'content', allowChangeEvent = false, } = opts;
                const relativeToEl = (relativeTo === 'content' ? this._positioningEl : this);
                // No content element? Fall back to just setting scale
                if (!relativeToEl || !this._positioningEl) {
                    this.setTransform({ scale, allowChangeEvent });
                    return;
                }
                const rect = relativeToEl.getBoundingClientRect();
                originX = getAbsoluteValue(originX, rect.width);
                originY = getAbsoluteValue(originY, rect.height);
                if (relativeTo === 'content') {
                    originX += this.x;
                    originY += this.y;
                }
                else {
                    const currentRect = this._positioningEl.getBoundingClientRect();
                    originX -= currentRect.left;
                    originY -= currentRect.top;
                }
                this._applyChange({
                    allowChangeEvent,
                    originX,
                    originY,
                    scaleDiff: scale / this.scale,
                });
            }
            /**
             * Update the stage with a given scale/x/y.
             */
            setTransform(opts = {}) {
                const { allowChangeEvent = false } = opts;
                const _scale = opts.scale || this.scale;
                let scale = _scale;
                let { x = this.x, y = this.y, } = opts;
                if(_scale < this.minScale ){
                    this.setTransform({scale:this.minScale+0.00001, x:0, y:0, allowChangeEvent:true});
                    return;
                };
            
                // If we don't have an element to position, just set the value as given.
                // We'll check bounds later.
                if (!this._positioningEl) {
                    this._updateTransform(scale, x, y, allowChangeEvent);
                    return;
                }
                // Get current layout
                const thisBounds = this.getBoundingClientRect();
                const positioningElBounds = this._positioningEl.getBoundingClientRect();
                // Not displayed. May be disconnected or display:none.
                // Just take the values, and we'll check bounds later.

                //if (!thisBounds.width || !thisBounds.height) {
                    this._updateTransform(scale, x, y, allowChangeEvent);
                    return;
                //}

                // Create points for _positioningEl.
                let topLeft = createPoint();
                topLeft.x = positioningElBounds.left - thisBounds.left;
                topLeft.y = positioningElBounds.top - thisBounds.top;
                let bottomRight = createPoint();
                bottomRight.x = positioningElBounds.width + topLeft.x;
                bottomRight.y = positioningElBounds.height + topLeft.y;
                // Calculate the intended position of _positioningEl.
                const matrix = createMatrix()
                    .translate(x, y)
                    .scale(scale)
                    // Undo current transform
                    .multiply(this._transform.inverse());
                topLeft = topLeft.matrixTransform(matrix);
                bottomRight = bottomRight.matrixTransform(matrix);
                // Ensure _positioningEl can't move beyond out-of-bounds.
                // Correct for x
                if (topLeft.x > thisBounds.width) {
                    x += thisBounds.width - topLeft.x;
                }
                else if (bottomRight.x < 0) {
                    x += -bottomRight.x;
                }
                // Correct for y
                if (topLeft.y > thisBounds.height) {
                    y += thisBounds.height - topLeft.y;
                }
                else if (bottomRight.y < 0) {
                    y += -bottomRight.y;
                }
                this._updateTransform(scale, x, y, allowChangeEvent);
                
            }
            /**
             * Update transform values without checking bounds. This is only called in setTransform.
             */
            _updateTransform(scale, x, y, allowChangeEvent) {
                // Return if there's no change
                if (scale === this.scale &&
                    x === this.x &&
                    y === this.y)
                    return;
                this._transform.e = x;
                this._transform.f = y;
                this._transform.d = this._transform.a = scale;
                this.style.setProperty('--x', this.x + 'px');
                this.style.setProperty('--y', this.y + 'px');
                this.style.setProperty('--scale', this.scale + '');
                if (allowChangeEvent) {
                    const event = new Event('change', { bubbles: true });
                    this.dispatchEvent(event);
                }
            }
            /**
             * Called when the direct children of this element change.
             * Until we have have shadow dom support across the board, we
             * require a single element to be the child of <pinch-zoom>, and
             * that's the element we pan/scale.
             */
            _stageElChange() {
                this._positioningEl = undefined;
                if (this.children.length === 0)
                    return;
                this._positioningEl = this.children[0];
                if (this.children.length > 1) {
                    console.warn('<pinch-zoom> must not have more than one child.');
                }
                // Do a bounds check
                this.setTransform({ allowChangeEvent: true });
            }
            _onWheel(event) {
                if (!this._positioningEl)
                    return;
                event.preventDefault();
                const currentRect = this._positioningEl.getBoundingClientRect();
                let { deltaY } = event;
                const { ctrlKey, deltaMode } = event;
                if (deltaMode === 1) { // 1 is "lines", 0 is "pixels"
                    // Firefox uses "lines" for some types of mouse
                    deltaY *= 15;
                }
                // ctrlKey is true when pinch-zooming on a trackpad.
                const divisor = ctrlKey ? 100 : 300;
                const scaleDiff = 1 - deltaY / divisor;
                this._applyChange({
                    scaleDiff,
                    originX: event.clientX - currentRect.left,
                    originY: event.clientY - currentRect.top,
                    allowChangeEvent: true,
                });
            }
            _onPointerMove(previousPointers, currentPointers) {
                if (!this._positioningEl)
                    return;
                // Combine next points with previous points
                const currentRect = this._positioningEl.getBoundingClientRect();
                // For calculating panning movement
                const prevMidpoint = getMidpoint(previousPointers[0], previousPointers[1]);
                const newMidpoint = getMidpoint(currentPointers[0], currentPointers[1]);
                // Midpoint within the element
                const originX = prevMidpoint.clientX - currentRect.left;
                const originY = prevMidpoint.clientY - currentRect.top;
                // Calculate the desired change in scale
                const prevDistance = getDistance(previousPointers[0], previousPointers[1]);
                const newDistance = getDistance(currentPointers[0], currentPointers[1]);
                const scaleDiff = prevDistance ? newDistance / prevDistance : 1;
                this._applyChange({
                    originX, originY, scaleDiff,
                    panX: newMidpoint.clientX - prevMidpoint.clientX,
                    panY: newMidpoint.clientY - prevMidpoint.clientY,
                    allowChangeEvent: true,
                });
            }
            /** Transform the view & fire a change event */
            _applyChange(opts = {}) {
                const { panX = 0, panY = 0, originX = 0, originY = 0, scaleDiff = 1, allowChangeEvent = false, } = opts;
                const matrix = createMatrix()
                    // Translate according to panning.
                    .translate(panX, panY)
                    // Scale about the origin.
                    .translate(originX, originY)
                    // Apply current translate
                    .translate(this.x, this.y)
                    .scale(scaleDiff)
                    .translate(-originX, -originY)
                    // Apply current scale.
                    .scale(this.scale);
                // Convert the transform into basic translate & scale.
                this.setTransform({
                    allowChangeEvent,
                    scale: matrix.a,
                    x: matrix.e,
                    y: matrix.f,
                });
            }
        }

        customElements.define('pinch-zoom', PinchZoom);

        return PinchZoom;

    }());
    </script>
</html>






